# 🚀 Déploiement avec CI/CD pour un projet Dockerisé

Ce guide explique comment mettre en place une **stratégie CI/CD complète** à partir de la branche `main` et en environnement multi-phases : `dev`, `staging`, `preprod`, `prod`.

---

## 🎯 Objectifs

- Comprendre le cycle de vie `dev → staging → preprod → prod`
- Automatiser le build, les tests, et le déploiement via GitLab CI, GitHub Actions ou autre outil CI/CD
- Optimiser les images Docker avec `.dockerignore`
- Éviter les erreurs manuelles et fiabiliser les mises en production

---

## 🧩 Étapes initiales (déploiement continu sur `main`)

### 1. Organisation des branches

| Branche | Rôle |
|--------|------|
| `main` | Branche stable avec déploiement automatique |
| `dev` | Développement actif, fonctionnalités en cours |
| `staging` | Tests d'intégration, qualité, validation client |
| `preprod` | Réplique de prod, dernière vérif avant go live |
| `prod` | Déploiement manuel validé pour les utilisateurs |

---

## ⚙️ Processus CI/CD de base (`main`)

1. Push sur `main`
2. CI déclenche :
   - Build de l’image Docker
   - Exécution des tests (PHPUnit, lint, etc.)
   - Push de l’image vers Docker Hub ou Registry Git
   - Déploiement sur un serveur VPS ou cloud (via SSH ou pipeline)
3. Notification de succès ou échec

---

## 📂 Exemple de `.dockerignore`

```txt
.git
tests
node_modules
vendor
*.log
.env
Dockerfile
docker-compose.yml
```

> ✅ Permet d’**alléger l’image Docker**, éviter d’exposer des fichiers sensibles, et **accélérer le build**.

---

## 🛠️ Exemple de pipeline GitLab CI (`.gitlab-ci.yml`)

```yaml
stages:
  - build
  - test
  - deploy

variables:
  DOCKER_DRIVER: overlay2

build:
  stage: build
  script:
    - docker build -t registry.gitlab.com/monprojet/app:$CI_COMMIT_SHORT_SHA .
    - docker push registry.gitlab.com/monprojet/app:$CI_COMMIT_SHORT_SHA

test:
  stage: test
  script:
    - docker run registry.gitlab.com/monprojet/app:$CI_COMMIT_SHORT_SHA vendor/bin/phpunit

deploy_prod:
  stage: deploy
  only:
    - main
  script:
    - ssh user@ip_vps "cd /home/user/app && git pull && docker-compose up -d --build"
```

---

## 🔁 Étapes complètes du workflow

### `dev` :
- Fonctionnalités en cours
- Tests en local et build manuel possible

### `staging` :
- Merge des PR
- CI déclenche tests + build d’image + scan de sécurité
- Déploiement automatique dans environnement de staging

### `preprod` :
- Approche manuelle ou semi-auto
- Tests utilisateurs, données proches de la prod

### `prod` :
- Déploiement **manuel et validé**
- Image finale poussée et utilisée

---

## ✅ Avantages de cette stratégie

- Séparation claire des environnements
- Réduction des erreurs humaines
- Historique des déploiements
- Intégration continue + feedback rapide
- Déploiement maîtrisé et reproductible

---

## 📦 Recommandations

- Toujours utiliser `.dockerignore` pour éviter les gros fichiers
- Versionner les images Docker (tag dynamique)
- Ne jamais stocker `.env` ou secrets dans le dépôt
- Tester les images localement avant de les publier
- Documenter chaque étape du pipeline dans le README

---

> Avec cette stratégie CI/CD, ton projet gagne en fiabilité, en vitesse de livraison, et en professionnalisme. 🔁🚀



## Mise à jour : Déploiement d'une image Docker depuis Docker Hub avec resync

Dans cette version du projet, l’image Docker est stockée sur **Docker Hub** (et non GitLab Container Registry). Voici comment adapter le processus CI/CD :

### 📦 Étapes mises à jour du pipeline :

#### 1. 🔁 Cloner le repo Git
Le pipeline CI/CD s’exécute depuis un dépôt Git (GitHub, GitLab, etc.) mais ne dépend plus du GitLab Registry.

#### 2. 🐳 Pull depuis Docker Hub
Dans le pipeline CI/CD, utilisez la commande suivante pour tirer votre image :

```yaml
script:
  - docker pull votre_identifiant_docker/votre_image:latest
```

Assurez-vous que l’image est publique sur Docker Hub, ou connectez-vous avec :

```yaml
before_script:
  - echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-stdin
```

Les variables `DOCKER_USERNAME` et `DOCKER_PASSWORD` doivent être définies dans les variables du CI/CD.

---

### 🔄 Utilisation de Resync pour déploiement automatique

[Resync](https://resync.io/) permet de synchroniser automatiquement vos fichiers entre votre poste local et un serveur (comme votre VPS). Utilisez-le dans ce cas pour remplacer le `scp` manuel.

Étapes :
1. Installez Resync sur votre machine et VPS.
2. Configurez un fichier `.resync.yml` :
```yml
sync:
  - source: .
    target: user@votre-ip:/home/user/app
    exclude:
      - .git
      - node_modules
      - vendor
      - .dockerignore
```
3. Lancez :
```bash
resync up
```

---

### 🚫 À ignorer à la fin du déploiement :

- Les dossiers inutiles (`.git`, `node_modules`, `vendor`)
- Les fichiers de configuration sensibles non utilisés (`.env`, `docker-compose.override.yml`, etc.)

Ajoutez-les à `.dockerignore` **et** à `.resync.yml` :
```txt
.git
node_modules
vendor
.dockerignore
.docker-compose.override.yml
```

Cela garantit que vos conteneurs et vos transferts restent propres et sécurisés.
