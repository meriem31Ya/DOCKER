# ğŸš€ DÃ©ploiement avec CI/CD pour un projet DockerisÃ©

Ce guide explique comment mettre en place une **stratÃ©gie CI/CD complÃ¨te** Ã  partir de la branche `main` et en environnement multi-phases : `dev`, `staging`, `preprod`, `prod`.

---

## ğŸ¯ Objectifs

- Comprendre le cycle de vie `dev â†’ staging â†’ preprod â†’ prod`
- Automatiser le build, les tests, et le dÃ©ploiement via GitLab CI, GitHub Actions ou autre outil CI/CD
- Optimiser les images Docker avec `.dockerignore`
- Ã‰viter les erreurs manuelles et fiabiliser les mises en production

---

## ğŸ§© Ã‰tapes initiales (dÃ©ploiement continu sur `main`)

### 1. Organisation des branches

| Branche | RÃ´le |
|--------|------|
| `main` | Branche stable avec dÃ©ploiement automatique |
| `dev` | DÃ©veloppement actif, fonctionnalitÃ©s en cours |
| `staging` | Tests d'intÃ©gration, qualitÃ©, validation client |
| `preprod` | RÃ©plique de prod, derniÃ¨re vÃ©rif avant go live |
| `prod` | DÃ©ploiement manuel validÃ© pour les utilisateurs |

---

## âš™ï¸ Processus CI/CD de base (`main`)

1. Push sur `main`
2. CI dÃ©clenche :
   - Build de lâ€™image Docker
   - ExÃ©cution des tests (PHPUnit, lint, etc.)
   - Push de lâ€™image vers Docker Hub ou Registry Git
   - DÃ©ploiement sur un serveur VPS ou cloud (via SSH ou pipeline)
3. Notification de succÃ¨s ou Ã©chec

---

## ğŸ“‚ Exemple de `.dockerignore`

```txt
.git
tests
node_modules
vendor
*.log
.env
Dockerfile
docker-compose.yml
```

> âœ… Permet dâ€™**allÃ©ger lâ€™image Docker**, Ã©viter dâ€™exposer des fichiers sensibles, et **accÃ©lÃ©rer le build**.

---

## ğŸ› ï¸ Exemple de pipeline GitLab CI (`.gitlab-ci.yml`)

```yaml
stages:
  - build
  - test
  - deploy

variables:
  DOCKER_DRIVER: overlay2

build:
  stage: build
  script:
    - docker build -t registry.gitlab.com/monprojet/app:$CI_COMMIT_SHORT_SHA .
    - docker push registry.gitlab.com/monprojet/app:$CI_COMMIT_SHORT_SHA

test:
  stage: test
  script:
    - docker run registry.gitlab.com/monprojet/app:$CI_COMMIT_SHORT_SHA vendor/bin/phpunit

deploy_prod:
  stage: deploy
  only:
    - main
  script:
    - ssh user@ip_vps "cd /home/user/app && git pull && docker-compose up -d --build"
```

---

## ğŸ” Ã‰tapes complÃ¨tes du workflow

### `dev` :
- FonctionnalitÃ©s en cours
- Tests en local et build manuel possible

### `staging` :
- Merge des PR
- CI dÃ©clenche tests + build dâ€™image + scan de sÃ©curitÃ©
- DÃ©ploiement automatique dans environnement de staging

### `preprod` :
- Approche manuelle ou semi-auto
- Tests utilisateurs, donnÃ©es proches de la prod

### `prod` :
- DÃ©ploiement **manuel et validÃ©**
- Image finale poussÃ©e et utilisÃ©e

---

## âœ… Avantages de cette stratÃ©gie

- SÃ©paration claire des environnements
- RÃ©duction des erreurs humaines
- Historique des dÃ©ploiements
- IntÃ©gration continue + feedback rapide
- DÃ©ploiement maÃ®trisÃ© et reproductible

---

## ğŸ“¦ Recommandations

- Toujours utiliser `.dockerignore` pour Ã©viter les gros fichiers
- Versionner les images Docker (tag dynamique)
- Ne jamais stocker `.env` ou secrets dans le dÃ©pÃ´t
- Tester les images localement avant de les publier
- Documenter chaque Ã©tape du pipeline dans le README

---

> Avec cette stratÃ©gie CI/CD, ton projet gagne en fiabilitÃ©, en vitesse de livraison, et en professionnalisme. ğŸ”ğŸš€



## Mise Ã  jour : DÃ©ploiement d'une image Docker depuis Docker Hub avec resync

Dans cette version du projet, lâ€™image Docker est stockÃ©e sur **Docker Hub** (et non GitLab Container Registry). Voici comment adapter le processus CI/CD :

### ğŸ“¦ Ã‰tapes mises Ã  jour du pipeline :

#### 1. ğŸ” Cloner le repo Git
Le pipeline CI/CD sâ€™exÃ©cute depuis un dÃ©pÃ´t Git (GitHub, GitLab, etc.) mais ne dÃ©pend plus du GitLab Registry.

#### 2. ğŸ³ Pull depuis Docker Hub
Dans le pipeline CI/CD, utilisez la commande suivante pour tirer votre image :

```yaml
script:
  - docker pull votre_identifiant_docker/votre_image:latest
```

Assurez-vous que lâ€™image est publique sur Docker Hub, ou connectez-vous avec :

```yaml
before_script:
  - echo "$DOCKER_PASSWORD" | docker login -u "$DOCKER_USERNAME" --password-stdin
```

Les variables `DOCKER_USERNAME` et `DOCKER_PASSWORD` doivent Ãªtre dÃ©finies dans les variables du CI/CD.

---

### ğŸ”„ Utilisation de Resync pour dÃ©ploiement automatique

[Resync](https://resync.io/) permet de synchroniser automatiquement vos fichiers entre votre poste local et un serveur (comme votre VPS). Utilisez-le dans ce cas pour remplacer le `scp` manuel.

Ã‰tapes :
1. Installez Resync sur votre machine et VPS.
2. Configurez un fichier `.resync.yml` :
```yml
sync:
  - source: .
    target: user@votre-ip:/home/user/app
    exclude:
      - .git
      - node_modules
      - vendor
      - .dockerignore
```
3. Lancez :
```bash
resync up
```

---

### ğŸš« Ã€ ignorer Ã  la fin du dÃ©ploiement :

- Les dossiers inutiles (`.git`, `node_modules`, `vendor`)
- Les fichiers de configuration sensibles non utilisÃ©s (`.env`, `docker-compose.override.yml`, etc.)

Ajoutez-les Ã  `.dockerignore` **et** Ã  `.resync.yml` :
```txt
.git
node_modules
vendor
.dockerignore
.docker-compose.override.yml
```

Cela garantit que vos conteneurs et vos transferts restent propres et sÃ©curisÃ©s.
